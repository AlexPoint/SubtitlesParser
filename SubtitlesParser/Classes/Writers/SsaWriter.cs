using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using SubtitlesParser.Classes.Utils;

namespace SubtitlesParser.Classes.Writers
{
    /// <summary>
    /// A writer for the Substation Alpha subtitles format.
    /// See http://en.wikipedia.org/wiki/SubStation_Alpha for complete explanations.
    /// Example output:
    /// [Script Info]
    /// ; Script generated by SubtitlesParser v1.4.9.0
    /// ; https://github.com/AlexPoint/SubtitlesParser
    /// ScriptType: v4.00
    /// WrapStyle: 3
    ///
    /// [Events]
    /// Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
    /// Dialogue: 0,0:18:03.87,0:18:04.23,,,0,0,0,,Oh?
    /// Dialogue: 0,0:18:05.19,0:18:05.90,,,0,0,0,,What was that?
    /// </summary>
    public class SsaWriter : ISubtitlesWriter
    {
        /// <summary>
        /// Write the SSA file header to a text writer 
        /// </summary>
        /// <param name="writer">The TextWriter to write to</param>
        private void WriteHeader(TextWriter writer)
        {
            writer.WriteLine(SsaFormatConstants.SCRIPT_INFO_LINE);
            writer.WriteLine($"{SsaFormatConstants.COMMENT} Script generated by SubtitlesParser v{GetType().Assembly.GetName().Version}");
            writer.WriteLine($"{SsaFormatConstants.COMMENT} https://github.com/AlexPoint/SubtitlesParser");
            writer.WriteLine("ScriptType: v4.00"); // the SSA format 
            writer.WriteLine("WrapStyle: 3"); // because we don't have any way to indicate where a line should be broken in plaintext, tell the player to auto-wrap (with a wider lower line) 
            writer.WriteLine(); // blank line between sections
            
            writer.Flush();
        }

        /// <summary>
        /// Asynchronously write the SSA file header to a text writer 
        /// </summary>
        /// <param name="writer">The TextWriter to write to</param>
        private async Task WriteHeaderAsync(TextWriter writer)
        {
            await writer.WriteLineAsync(SsaFormatConstants.SCRIPT_INFO_LINE);
            await writer.WriteLineAsync($"{SsaFormatConstants.COMMENT} Script generated by SubtitlesParser v{GetType().Assembly.GetName().Version}");
            await writer.WriteLineAsync($"{SsaFormatConstants.COMMENT} https://github.com/AlexPoint/SubtitlesParser");
            await writer.WriteLineAsync("ScriptType: v4.00"); // the SSA format 
            await writer.WriteLineAsync("WrapStyle: 3"); // because we don't have any way to indicate where a line should be broken in plaintext, tell the player to auto-wrap (with a wider lower line)
            await writer.WriteLineAsync(); // blank line between sections

            await writer.FlushAsync();
        }

        /// <summary>
        /// Converts a subtitle item into an SSA formatted dialogue line
        /// </summary>
        /// <param name="subtitleItem">The SubtitleItem to convert</param>
        /// <returns>The full dialogue line</returns>
        private string SubtitleItemToDialogueLine(SubtitleItem subtitleItem)
        {
            string[] fields = new string[10]; // style, name, and effect fields are left blank
            fields[0] = "0"; // layer
            fields[1] = TimeSpan.FromMilliseconds(subtitleItem.StartTime).ToString(@"h\:mm\:ss\.ff"); // start
            fields[2] = TimeSpan.FromMilliseconds(subtitleItem.EndTime).ToString(@"h\:mm\:ss\.ff"); // end
            fields[5] = "0"; // left margin
            fields[6] = "0"; // right margin 
            fields[7] = "0"; // vertical margin
            // combine all items in the `Lines` property into a single string, with each item being seperated by an SSA newline (\N) 
            fields[9] = subtitleItem.Lines.Aggregate(string.Empty, (current, line) => current + $"{line}\\N").TrimEnd('\\', 'N'); // text

            StringBuilder builder = new StringBuilder(SsaFormatConstants.DIALOGUE_PREFIX);
            return builder.AppendJoin(SsaFormatConstants.SEPARATOR, fields).ToString();
        }

        /// <summary>
        /// Write a list of subtitle items to a stream in the SSA/ASS format synchronously
        /// </summary>
        /// <param name="stream">The stream to write to</param>
        /// <param name="subtitleItems">The subtitle items to write</param>
        public void WriteStream(Stream stream, IEnumerable<SubtitleItem> subtitleItems)
        {
            using TextWriter writer = new StreamWriter(stream);
            WriteHeader(writer);

            writer.WriteLine(SsaFormatConstants.EVENT_LINE);
            writer.WriteLine("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"); // column headers
            foreach (SubtitleItem item in subtitleItems)
                writer.WriteLine(SubtitleItemToDialogueLine(item));
        }

        /// <summary>
        /// Write a list of subtitle items to a stream in the SSA/ASS format asynchronously
        /// </summary>
        /// <param name="stream">The stream to write to</param>
        /// <param name="subtitleItems">The subtitle items to write</param>
        public async Task WriteStreamAsync(Stream stream, IEnumerable<SubtitleItem> subtitleItems)
        {
            await using TextWriter writer = new StreamWriter(stream);
            await WriteHeaderAsync(writer);

            await writer.WriteLineAsync(SsaFormatConstants.EVENT_LINE);
            await writer.WriteLineAsync("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"); // column headers
            foreach (SubtitleItem item in subtitleItems)
                await writer.WriteLineAsync(SubtitleItemToDialogueLine(item));
        }
    }
}
